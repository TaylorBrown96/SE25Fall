name: CI

on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ "main" ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    defaults:
      run:
        working-directory: proj2  # run everything from proj2/

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          set -e
          pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pytest pytest-timeout 
        
      - name: Run tests with retry
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 25
          max_attempts: 3
          # retry_on: error
          command: |
            set -euo pipefail
            export PYTHONUNBUFFERED=1
            # unique file per attempt; GITHUB_RUN_ATTEMPT is stable, add a seconds stamp too
            LOG="$GITHUB_WORKSPACE/pytest_attempt_${GITHUB_RUN_ATTEMPT}_$(date +%s).log"
            # stream to console AND write to file; pipefail keeps pytest’s exit status
            stdbuf -oL -eL pytest -vv --log-cli-level=INFO --maxfail=1 --timeout=120 --durations=10 2>&1 | tee "$LOG"

      - name: Check code formatting (Black)
        run: |
          set -e
          black .
          black --check .

      - name: Lint code (Ruff)
        run: |
          set -e
          ruff check . --fix || true  

      - name: Set PYTHONPATH
        run: echo "PYTHONPATH=$GITHUB_WORKSPACE" >> $GITHUB_ENV

      - name: Run tests with coverage
        run: |
          set -e
          pytest
        env:
          PYTHONPATH: ${{ env.PYTHONPATH }}

      - name: Upload coverage.xml as artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: proj2/coverage.xml
          if-no-files-found: warn

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}   # rotate & set in repo secrets
          files: proj2/coverage.xml
          flags: proj2
          name: proj2-coverage
          fail_ci_if_error: true
          verbose: true

      - name: Compute tests badge JSON
        id: badge
        if: always()  # update even on failures so the badge can go red
        run: |
          OUT="$(pytest || true)"
          SUMMARY=$(echo "$OUT" | grep -Eo '[0-9]+ (passed|failed|skipped|xfailed|xpassed)' | tr '\n' ' ')
          PASSED=$(echo "$SUMMARY" | grep -Eo '[0-9]+ passed' | awk '{print $1}' || echo 0)
          FAILED=$(echo "$SUMMARY" | grep -Eo '[0-9]+ failed' | awk '{print $1}' || echo 0)
          TOTAL=$((PASSED + FAILED))
          if [ "${FAILED:-0}" != "0" ]; then
            COLOR=critical
            MSG="$PASSED/$TOTAL passing"
          else
            COLOR=success
            MSG="$PASSED passing"
          fi
          BADGE=$(printf '{ "schemaVersion": 1, "label": "tests", "message": "%s", "color": "%s" }' "$MSG" "$COLOR")
          echo "badge=${BADGE}" >> "$GITHUB_OUTPUT"

      - name: Update tests badge (gist)
        if: always()
        uses: actions/github-script@v7
        env:
          GIST_ID: 0c223cf33bf0cc9b91667676c415aafa
          GIST_FILE: tests-badge.json
          CONTENT: ${{ steps.badge.outputs.badge }}
        with:
          github-token: ${{ secrets.GIST_TOKEN }} # classic PAT with "gist" scope
          script: |
            const gistId = process.env.GIST_ID;
            const file = process.env.GIST_FILE;
            let content = process.env.CONTENT;

            // Fallback if previous step didn't set CONTENT
            if (!content || !content.trim()) {
              content = JSON.stringify({
                schemaVersion: 1,
                label: "tests",
                message: "unknown",
                color: "inactive"
              });
            }

            // Ensure it's a string (not accidentally an object)
            if (typeof content !== "string") {
              content = JSON.stringify(content);
            }

            await github.rest.gists.update({
              gist_id: gistId,
              files: { [file]: { content } }
            });

      - name: Upload pytest logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-logs
          path: ${{ github.workspace }}/pytest_attempt_*.log